//--------------------------------------------------------------------------------
// Code generated by jFuzzyLogic
// jFuzzyLogic Version : JFuzzyLogic 3.3 (build 2015-04-09), by Pablo Cingolani 
// jFuzzyLogic creted by Pablo Cingolani
//--------------------------------------------------------------------------------

#include <stdio.h>
#include <iostream>
#include <stdlib.h>

using namespace std;

double ruleAccumulationMethod_max(double defuzzifierValue, double valueToAggregate) { return (defuzzifierValue > valueToAggregate ? defuzzifierValue : valueToAggregate); }

double ruleActivationMethod_min(double degreeOfSupport, double membership) { return (degreeOfSupport < membership ? degreeOfSupport : membership); }

double ruleConnectionMethod_and(double antecedent1, double antecedent2) { return (antecedent1 < antecedent2 ? antecedent1 : antecedent2); }

class FunctionBlock_car {

public:
	// VAR_INPUT
	double distance;
	double speed;

	// VAR_OUTPUT
	double speed_change;

private:
	// FUZZIFY distance
	double distance_far;
	double distance_near;

	// FUZZIFY speed
	double speed_fast;
	double speed_slow;


	// DEFUZZIFY speed_change
	double defuzzify_speed_change[1000];


public:
	FunctionBlock_car();
	void calc();
	void print();

private:
	void defuzzify();
	void fuzzify();
	void reset();
	double membership_distance_far(double x);
	double membership_distance_near(double x);
	double membership_speed_fast(double x);
	double membership_speed_slow(double x);
	double membership_speed_change_increase(double x);
	double membership_speed_change_keep(double x);
	double membership_speed_change_reduce(double x);
	void calc_No1();

};

// Constructor
FunctionBlock_car::FunctionBlock_car() {
	speed_change = 0.0;
}

// Calculate function block
void FunctionBlock_car::calc() {
	reset();
	fuzzify();
	calc_No1();
	defuzzify();
}

// RULEBLOCK No1
void FunctionBlock_car::calc_No1() {
	// RULE 1 : IF (distance IS near) AND (speed IS slow) THEN speed_change IS keep;
	double degreeOfSupport_1 = 1.0 * (ruleConnectionMethod_and(distance_near, speed_slow));
	if (degreeOfSupport_1 > 0) {
		for (int i = 0; i < 1000; i++) {
			double x = -10.0 + i * 0.02;
			double membership = membership_speed_change_keep(x);
			double y = ruleActivationMethod_min(degreeOfSupport_1, membership);
			defuzzify_speed_change[i] += ruleAccumulationMethod_max(defuzzify_speed_change[i], y);
		}
	}

	// RULE 2 : IF (distance IS near) AND (speed IS fast) THEN speed_change IS reduce;
	double degreeOfSupport_2 = 1.0 * (ruleConnectionMethod_and(distance_near, speed_fast));
	if (degreeOfSupport_2 > 0) {
		for (int i = 0; i < 1000; i++) {
			double x = -10.0 + i * 0.02;
			double membership = membership_speed_change_reduce(x);
			double y = ruleActivationMethod_min(degreeOfSupport_2, membership);
			defuzzify_speed_change[i] += ruleAccumulationMethod_max(defuzzify_speed_change[i], y);
		}
	}

	// RULE 3 : IF (distance IS far) AND (speed IS slow) THEN speed_change IS increase;
	double degreeOfSupport_3 = 1.0 * (ruleConnectionMethod_and(distance_far, speed_slow));
	if (degreeOfSupport_3 > 0) {
		for (int i = 0; i < 1000; i++) {
			double x = -10.0 + i * 0.02;
			double membership = membership_speed_change_increase(x);
			double y = ruleActivationMethod_min(degreeOfSupport_3, membership);
			defuzzify_speed_change[i] += ruleAccumulationMethod_max(defuzzify_speed_change[i], y);
		}
	}

	// RULE 4 : IF (distance IS far) AND (speed IS fast) THEN speed_change IS keep;
	double degreeOfSupport_4 = 1.0 * (ruleConnectionMethod_and(distance_far, speed_fast));
	if (degreeOfSupport_4 > 0) {
		for (int i = 0; i < 1000; i++) {
			double x = -10.0 + i * 0.02;
			double membership = membership_speed_change_keep(x);
			double y = ruleActivationMethod_min(degreeOfSupport_4, membership);
			defuzzify_speed_change[i] += ruleAccumulationMethod_max(defuzzify_speed_change[i], y);
		}
	}

}

// Defuzzify 
void FunctionBlock_car::defuzzify() {
	double sum_speed_change = 0.0;
	double wsum_speed_change = 0.0;
	for (int i = 0; i < 1000; i++) {
		double x = -10.0 + i * 0.02;
		sum_speed_change += defuzzify_speed_change[i];
		wsum_speed_change += x * defuzzify_speed_change[i];
	}
	speed_change = wsum_speed_change / sum_speed_change;
}

// Fuzzify all variables
void FunctionBlock_car::fuzzify() {
	distance_far = membership_distance_far(distance);
	distance_near = membership_distance_near(distance);
	speed_fast = membership_speed_fast(speed);
	speed_slow = membership_speed_slow(speed);
}

// Membership functions 
double FunctionBlock_car::membership_distance_far(double x) {
	if (x <= 0.0)	return 0.0;
	if (x > 1000.0)	return 1.0;
	if (x <= 100.0)	return 0.0 + (0.0 - 0.0) * ((x - 0.0) / (100.0 - 0.0));
	if (x <= 400.0)	return 0.0 + (1.0 - 0.0) * ((x - 100.0) / (400.0 - 100.0));
	if (x <= 1000.0)	return 1.0 + (1.0 - 1.0) * ((x - 400.0) / (1000.0 - 400.0));
}

double FunctionBlock_car::membership_distance_near(double x) {
	if (x <= 0.0)	return 1.0;
	if (x > 1000.0)	return 0.0;
	if (x <= 100.0)	return 1.0 + (1.0 - 1.0) * ((x - 0.0) / (100.0 - 0.0));
	if (x <= 300.0)	return 1.0 + (0.0 - 1.0) * ((x - 100.0) / (300.0 - 100.0));
	if (x <= 1000.0)	return 0.0 + (0.0 - 0.0) * ((x - 300.0) / (1000.0 - 300.0));
}

double FunctionBlock_car::membership_speed_fast(double x) {
	if (x <= 0.0)	return 0.0;
	if (x > 120.0)	return 1.0;
	if (x <= 50.0)	return 0.0 + (0.0 - 0.0) * ((x - 0.0) / (50.0 - 0.0));
	if (x <= 80.0)	return 0.0 + (1.0 - 0.0) * ((x - 50.0) / (80.0 - 50.0));
	if (x <= 120.0)	return 1.0 + (1.0 - 1.0) * ((x - 80.0) / (120.0 - 80.0));
}

double FunctionBlock_car::membership_speed_slow(double x) {
	if (x <= 0.0)	return 1.0;
	if (x > 120.0)	return 0.0;
	if (x <= 50.0)	return 1.0 + (1.0 - 1.0) * ((x - 0.0) / (50.0 - 0.0));
	if (x <= 80.0)	return 1.0 + (0.0 - 1.0) * ((x - 50.0) / (80.0 - 50.0));
	if (x <= 120.0)	return 0.0 + (0.0 - 0.0) * ((x - 80.0) / (120.0 - 80.0));
}

double FunctionBlock_car::membership_speed_change_increase(double x) {
	if (x <= -10.0)	return 0.0;
	if (x > 10.0)	return 1.0;
	if (x <= 0.0)	return 0.0 + (0.0 - 0.0) * ((x - -10.0) / (0.0 - -10.0));
	if (x <= 5.0)	return 0.0 + (1.0 - 0.0) * ((x - 0.0) / (5.0 - 0.0));
	if (x <= 10.0)	return 1.0 + (1.0 - 1.0) * ((x - 5.0) / (10.0 - 5.0));
}

double FunctionBlock_car::membership_speed_change_keep(double x) {
	if (x <= -10.0)	return 0.0;
	if (x > 10.0)	return 0.0;
	if (x <= -5.0)	return 0.0 + (0.0 - 0.0) * ((x - -10.0) / (-5.0 - -10.0));
	if (x <= 0.0)	return 0.0 + (1.0 - 0.0) * ((x - -5.0) / (0.0 - -5.0));
	if (x <= 5.0)	return 1.0 + (0.0 - 1.0) * ((x - 0.0) / (5.0 - 0.0));
	if (x <= 10.0)	return 0.0 + (0.0 - 0.0) * ((x - 5.0) / (10.0 - 5.0));
}

double FunctionBlock_car::membership_speed_change_reduce(double x) {
	if (x <= -10.0)	return 1.0;
	if (x > 10.0)	return 0.0;
	if (x <= -5.0)	return 1.0 + (1.0 - 1.0) * ((x - -10.0) / (-5.0 - -10.0));
	if (x <= 0.0)	return 1.0 + (0.0 - 1.0) * ((x - -5.0) / (0.0 - -5.0));
	if (x <= 10.0)	return 0.0 + (0.0 - 0.0) * ((x - 0.0) / (10.0 - 0.0));
}


// Print 
void FunctionBlock_car::print() {
	printf("Function block car:\n");
	printf("	Input  %20s : %f\n", "distance", distance);
	printf("	       %20s : %f\n", "distance_far", distance_far);
	printf("	       %20s : %f\n", "distance_near", distance_near);
	printf("	Input  %20s : %f\n", "speed", speed);
	printf("	       %20s : %f\n", "speed_fast", speed_fast);
	printf("	       %20s : %f\n", "speed_slow", speed_slow);
	printf("	Output %20s : %f\n", "speed_change", speed_change);
}

// Reset output
void FunctionBlock_car::reset() {
	for (int i = 0; i < 1000; i++) { defuzzify_speed_change[i] = 0.0; }
}

int main() {
	// Create function blocks
	FunctionBlock_car car;

	// Parse input
	car.distance = 1000;
	car.speed = 0;

	while (car.distance >=0) {
		car.calc();
		car.speed += car.speed_change/3.6;
		car.distance -= car.speed;
		cout << "Distance: " << car.distance << " Speed: " << car.speed << " Speed Change: " << car.speed_change << endl;
	}

	// Calculate
	car.calc();

	cout << car.speed_change << endl;

	// Show results
	car.print();
}
